//Raymond@HZHL3 ~/code/scribble-java/scribble-java
//$ java -cp modules/cli/target/classes/';'modules/core/target/classes';'modules/trace/target/classes';'modules/parser/target/classes';c:\Users\Raymond\.m2\repository\org\antlr\antlr-runtime\3.2\antlr-runtime-3.2.jar;'modules/validation/target/classes/';'modules/projection/target/classes/';C:\Users\Raymond\.m2\repository\org\codehaus\jackson\jackson-mapper-asl\1.9.9\jackson-mapper-asl-1.9.9.jar;C:\Users\Raymond\.m2\repository\org\codehaus\jackson\jackson-core-asl\1.9.9\jackson-core-asl-1.9.9.jar' org.scribble.cli.CommandLine -path modules/validation/src/test/scrib/src/ -validate Test

//$ java -cp modules/cli/target/classes/';'modules/core/target/classes';'modules/trace/target/classes';'modules/parser/target/classes';c:\Users\Raymond\.m2\repository\org\antlr\antlr-runtime\3.2\antlr-runtime-3.2.jar;'modules/validation/target/classes/';'modules/projection/target/classes/';C:\Users\Raymond\.m2\repository\org\codehaus\jackson\jackson-mapper-asl\1.9.9\jackson-mapper-asl-1.9.9.jar;C:\Users\Raymond\.m2\repository\org\codehaus\jackson\jackson-core-asl\1.9.9\jackson-core-asl-1.9.9.jar' org.scribble.cli.CommandLine -path modules/core/src/test/scrib/ modules/core/src/test/scrib/Test.scr
//$ java -cp modules/cli/target/classes/';'modules/core/target/classes';'modules/trace/target/classes';'modules/parser/target/classes';c:\Users\Raymond\.m2\repository\org\antlr\antlr-runtime\3.2\antlr-runtime-3.2.jar;'modules/validation/target/classes/';'modules/projection/target/classes/';C:\Users\Raymond\.m2\repository\org\codehaus\jackson\jackson-mapper-asl\1.9.9\jackson-mapper-asl-1.9.9.jar;C:\Users\Raymond\.m2\repository\org\codehaus\jackson\jackson-core-asl\1.9.9\jackson-core-asl-1.9.9.jar' org.scribble2.cli.CommandLine -path modules/validation/src/test/scrib/src modules/validation/src/test/scrib/src/Test.scr

//$ bin/scribblec.sh modules/core/src/test/scrib/Test.scr -ip modules/core/src/test/scrib/ -d modules/core/src/test/scrib/
 
//http://sandbox.kidstrythisathome.com/erdos/


module Test;


// Try an unfolding visitor that cuts off on nested unfolding of a rec as a continue -- no still won't solve mixed continue-onlys
// Need to record the "next action and state" after a recursion entry, and for continue only use that action to go to that state
// Or maybe try a "forwards" algorithm again (two passes may be easier)


global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;  // FIXME: no reception error, but deadlocked
			continue X;
		}		
		or
		{
			2() from A to C;
		}
	}
}	


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		rec X
		{
			1() from A to B;
			//1() from A to C;
			continue X;
		}	
	}	
	or
	{
		2() from A to B;
		2() from A to C;  // FIXME: add deadlock freedom check -- actually "role liveness"?, could do on a global model (but maybe just syntactically by paths)
	 }	
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		1() from A to B;
		//1() from B to C;  // bad
		//2() from A to C;  // bad
		//1() from A to C;  // ok
		choice at A
		{
			1() from A to C;
			continue X;
		}	
		or
		{
			2() from A to B;
			2() from A to C;
		}	
	}
}	
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		choice at A  // TODO: add to test suite (testing projection)
		{
			2() from A to C;
		}
		or
		{
			rec X
			{
				3() from A to C;
			}
		}
	}
	or
	{
		rec Y
		{
			2() from A to B;
		}
		4() from A to C;
	}	
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		0() from A to B;
		choice at A
		{
			rec X  // Checking FSM generation -- unfolding of unguarded shadowed choice-rec
			{
				1() from A to B;
				continue X;
			}	
		}	
		or
		{
			2() from A to B;
		}	
	}
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		0() from A to B;
		choice at A
		{
			//1() from A to B;
			continue X;
		}
		or
		{
			2() from A to B;
			//continue X;
		}
	}
	3() from A to B;
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	rec Y
	{
		0() from A to B;
		rec X
		{
			1() from A to B;
			choice at A
			{
				continue X;  // Check FSM building
			}
			or
			{
				2() from A to B;
			}	
			or
			{
				continue Y;
			}
		}	
	}
}	
//*/


/*// TODO: add to test suite
global protocol Proto1(role A, role B, role C)
{
	rec Y
	{
		rec Z
		{
			0() from A to C;
			rec X
			{
				choice at A
				{
					1() from A to B;
					continue X;
				}	
				or
				{
					2() from A to B;
					continue Y;  // Testing "pruning" of irrelevant continue cases in nested recs
				}	
				or
				{
					3a() from A to B;
					3b() from A to C;
				}	
			}	
		}
	}
	4() from B to C;
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;  // Comment is bad
		choice at A
		{
			continue X;
		}
		or
		{
			rec Y
			{
				2() from A to B;
				choice at A
				{
					//continue Y;  // Uncomment is bad
					continue X;
				}
				or
				{
					2() from A to B;  // OK to be 2 as well because the above X goes to 1() first
				}	
				/*or
				{
					3() from A to B;
					continue Y;
				}* /
			}
		}	
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		rec X
		{
			choice at A
			{
				1() from A to B;
				continue X;
			}
			or
			{
				2() from A to B;
				continue X;
			}
		}
	}
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;
		choice at A
		{
			continue X;
		}
		or
		{
			2() from A to B;
			continue X;
		}
	}
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		//0() from A to B;
		rec X  // Testing unguarded choice-rec at root...
		{
			1() from A to B;
			choice at A
			{
				2() from A to B;
			}
			or
			{
				continue X;  // ..in conjunction with unguarded choice-continue at the same time (just one at a time is fine) // FIXME (maybe just rule out by WF)
			}
		}
	}
	or
	{
		3() from A to B;
	}
}	
//*/


/*
global protocol Proto1(role A, role B)
{
	rec X
	{
		1() from A to B;  // Test different comment combinations with 1 and 3 and continue X
		choice at A
		{
			//3() from A to B;
			continue X;
		}	
		or
		{
			rec Y  // Testing nested InlinedProtocolUnfolding case
			{
				2() from A to B;
				//continue X;
				continue Y;
			}
		}
	}	
}	
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	3() from A to C;
	rec Y
	{
		2() from A to B;  // Uncomment is bad (non-enabled B / non-disjoint labels)
		2a() from B to A;
		rec X
		{
			1() from A to B;
			choice at A
			{
				//2() from A to B;
				continue X;  // Testing project choice subject "inference", and testing continue-only choice block
			}	
			or
			{
				continue Y;  // Different continue-onlys, tests FSM building
			}
			/*or  // Uncomment is bad (non-disjoint labels)
			{
				continue X;
			}* /
			or
			{
				4() from A to B;
			}	
		}	
	}
}	
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1() from A to B;
	2() from A to C;
	rec X
	{
		/*choice at A
		{
			3() from A to B;
		}* /
		choice at A
		{
			rec Y
			{
				choice at A
				{
					3() from A to B;
					continue X;
				}
				or
				{
					4() from A to B;
					continue Y;
				}
				or
				{
					5() from A to B;
				}
			}
		}
	}
}
//*/


/*
global protocol Proto1(role C, role S)
{
	choice at C
	{
		//0() from C to S;
		choice at S  // Fixed peekParentEnv index bug for enabled choice subjs
		{
			1() from S to C;
		}	
	}	
	/*rec X {
		choice at C {
			0() from C to S;
			rec Y {
				1() from S to C;
			}
		}
	//}* /

	/*choice at C
	{
		0() from C to S;
		//1() from S to C;
		//do Request(C, S);
		do Response(C, S);
	}*/
}
//*/


/*//global protocol Proto1(role A, role B, role C)
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;
		//1() from A to C;
	}
	or
	{
		2() from A to B;
		//2() from B to C;
	}	
}*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;
		2() from B to A;
		choice at A  // Nested choice: check for distinct enabling messages in path collection is not broken for the two paths in this choice induced by nested choice
		{
			3a() from A to B;
		}
		or
		{
			3b() from A to B;
		}
	}
	4() from B to A;
	choice at A
	{
		5a() from A to B;
	}
	or
	{
		5b() from A to B;
	}
	// Check path collection
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	rec X
	{
		choice at A
		{
			1() from A to B;
			1() from B to C;
		}
		or
		{
			2() from A to B;
			//4() from B to C;
			continue X;
		}
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1() from A to B;
	1() from A to C;
	choice at A
	{
		do Proto1(A, B, C);
	}
	or
	{
		2() from A to B;
		2() from A to C;
	}	

	/*choice at A
	{
		1() from A to B;
		1() from A to C;
	}
	or
	{
		2() from A to B;
		2() from A to C;
	}*/
	/*rec X
	{
		choice at A
		{
			1() from A to B;
			1() from A to C;
			continue X;
		}
		or
		{
			2() from A to B;
			2() from A to C;
		}	
	}*/
	/*rec Y
	{
		choice at A
		{
			rec X
			{
				choice at A
				{
					1() from A to B;
					continue X;
				}
				or
				{
					2() from A to C;
					continue Y;
				}	
				or
				{
					3() from A to B;
					3() from B to C;
				}	
			}	
		}
		or
		{
			4() from A to B;
			continue Y;
		}	
	}* /
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
		3() from B to C;
	}
	or
	{
		2() from A to B;
		3() from B to C;  // FIXME: same continuation for C, can fix by mergability (other than just factoring out)
	}
}
//*/


/*
type <java> "java.lang.String" from "rt.jar" as String;  

global protocol ExchangeKeyPairs(role Alice, role Bob) {  
	FriendRequest_FirstHalf_APublicKey(String) from Alice to Bob;
	FirstHalf_BPublicKey(String) from Bob to Alice;
	SecondHalf_APublicKey(String) from Alice to Bob;
	SecondHalf_BPublicKey(String) from Bob to Alice;
	SymmetricKey(String) from Alice to Bob;
	do SignPublicKeys(Bob, Alice);
	do SignPublicKeys(Alice, Bob);
}

global protocol SignPublicKeys(role Alice, role Bob) {
	RequestSignKey(String) from Alice to Bob;
	SignedKey(String) from Bob to Alice;
}

global protocol FriendRequestCommon(role Alice, role Bob, role Charlie) {
	FriendRequest(String) from Alice to Bob;
	FriendRequest(String) from Bob to Charlie;
	
	choice at Charlie {
		Accept(String) from Charlie to Bob;
		Accept(String) from Bob to Alice;
		do ExchangeKeyPairs(Alice, Charlie);
	} 
	or {
		Reject(String) from Charlie to Bob;
		Reject(String) from Bob to Alice;
	} 
}


global protocol UpdateIndexList(role Alice, role Friend, role FriendsFriend) {
	
	rec foreachFriendOfAlice {
		//GetIndexList inline start
		RequestIndexData(String) from Alice to Friend;
		/*interruptible{
			SendIndexData(String) from Friend to Alice;
		} with {
			Timeout(String) by Alice;
		}* / 
	
		rec foreachFriendOfAliceAtFriendsFriend {
			RequestFriendsIndexData(String) from Alice to FriendsFriend;
			choice at FriendsFriend {
				SendFriendsIndexeData(String) from FriendsFriend to Alice;
			}
			or {
				//FriendsFriend doesn't have Friends index data
				Decline(String) from FriendsFriend to Alice; 
				/*choice at Alice {
					continue foreachFriendOfAlice;
				}* /
			}
		}
		//GetIndexList inline end
		
		choice at Alice { // If Alice is missing post from Friend
			rec foreachMissingPost {

				RequestMissingData(String) from Alice to Friend;
				interruptible{MissingData(String) from Friend to Alice;} with {Timeout(String) by Alice;}	
			
				choice at Alice { // if Bob doesn't respond
					rec foreachFriendOfAlice2 {
						RequestBobData(String) from Alice to FriendsFriend;
						choice at FriendsFriend { // if Friend has Bob's data:
							BobData(String) from FriendsFriend to Alice;
						}
						or {
							Decline(String) from FriendsFriend to Alice;
						}
						
						/*choice at Alice {
							continue foreachFriendOfAlice;
						}* /
					}	
				}
				
				/*choice at Alice {
					continue foreachMissingPost;
				}* /
			}
		}
		or {
			Accept(String) from Alice to Friend;
			1() from Alice to FriendsFriend;
		}
	
		/*choice at Alice {
			continue foreachFriendOfAlice;
		}* /
	}
}

/*global protocol GetIndexList(role Alice, role Bob, role Friend) {
	
	RequestIndexData(String) from Alice to Bob;
	//interruptible{SendIndexData(String) from Bob to Alice;} with {Timeout(String) by Alice;}	 

	rec foreachFriendOfAlice {
		RequestBobsIndexData(String) from Alice to Friend;
		choice at Friend {
			SendBobsIndexeData(String) from Friend to Alice;
		}
		or {
			Decline(String) from Friend to Alice; //Friend doesn't have Bobs index data
			choice at Alice {
				continue foreachFriendOfAlice;
			}
		}
	}
}

global protocol SendIP(role Alice, role Friend) {
	
	rec foreachFriendOfAlice {
		AliceIP(String) from Alice to Friend;
		choice at Alice {
			continue foreachFriendOfAlice;
		}
	}
}


global protocol GetIP(role Alice, role ForeignIP, role FriendWithKnownIP) {
	
	rec foreachFriendOfAlice {
		rec foreachIPAddressInFriendsIPCache {
			RequestResponse(String) from Alice to ForeignIP;
			//interruptible{Response(String) from ForeignIP to Alice;} with {Timeout(String) by Alice;}	
			FriendsIdAndAliceId(String) from Alice to ForeignIP; //sent ID's to friend to let him confirm they are already friends
			choice at ForeignIP { //if Foreign IP verifies the ID's
				confirm(String) from ForeignIP to Alice;
			}
			or {
				Deny(String) from ForeignIP to Alice;
			}
			choice at Alice {
				continue foreachIPAddressInFriendsIPCache;
			}	
		}
		choice at Alice {
			continue foreachFriendOfAlice;
		}
	}
	
	rec foreachFriendOfAliceWithUnknownIP {
		rec foreachFriendOfAliceWithKnownIP {
			RequestIPAddressOfFriendWithUnknownIP(String) from Alice to FriendWithKnownIP;
			choice at FriendWithKnownIP { // if FriendWithKnownIP knows the requested friend and the timestamp is newer
				ForeignIP(String) from FriendWithKnownIP to Alice;
				RequestResponse(String) from Alice to ForeignIP; 
				//interruptible{Response(String) from ForeignIP to Alice;} with {Timeout(String) by Alice;}
				FriendsIdAndAliceId(String) from Alice to ForeignIP;
				choice at ForeignIP { // if ForeignIP verifies the ID's
					Confirm(String) from ForeignIP to Alice;
				}
				or {
					Deny(String) from ForeignIP to Alice;
				}
			}
			or {
				Decline(String) from FriendWithKnownIP to Alice;
			}
			choice at Alice {
				continue foreachFriendOfAliceWithKnownIP;
			}	
		}
		choice at Alice {
			continue foreachFriendOfAliceWithUnknownIP;
		}
	}
}


//global protocol FriendSearch(role Alice, role Bob, role Friend, role FriendsFriend) {
global protocol FriendSearch(role Alice, role Friend, role FriendsFriend) {
	
	rec foreachFriendOfAlice {
		RequestBob(String) from Alice to Friend;
		choice at Alice {
			continue foreachFriendOfAlice;
		}
	}
	
	/*interruptible{
		SendBob(String) from Friend to Alice;
	} with {
		Timeout(String) by Alice;
	} // ER DET HER OK?* /
	
	choice at Alice { // if Alice still hasn't found Bob
	
		rec foreachFriendOfAlice2 {
			FindBob() from Alice to Friend;
			rec foreachFriendsFriendOfFriend {	
				RequestFriend(String) from Friend to FriendsFriend;
				choice at FriendsFriend { // if FriendsFriend is friends with Bob
					SendBob(String) from FriendsFriend to Friend;
					SendBob(String) from Friend to Alice;	
				}
				choice at Alice {
					continue foreachFriendsFriendOfFriend;
				}
			}
			/*choice at Alice {
				continue foreachFriendOfAlice2;
			}* /
		}	
	}
}


global protocol NewDeviceLogin(role Alice, role Bob) {
	
	LoginInformation(String) from Bob to Alice;
	
	choice at Alice { // if Alice validates login information
		Accept(String) from Alice to Bob;
		do ExchangeKeyPairs(Bob, Alice);
		SendAllData(String) from Alice to Bob;
	}
	or {
		Decline(String) from Alice to Bob;
	}
}
//*/


/*
global protocol Tele(role A, role S, role B)
{
	//rec Idle // this is actually end of session
	{
		ac() from A to S;
		interruptible at A
		{
			rec Checking
			{
				checkb() from S to B;
				choice at B
				{
					available from B to S;
					ringa from S to A;
					choice at A
					{
						answera from A to S;
						ringb from S to B;
						choice at B
						{
							answerb from B to S;
							connect from S to A;
						}
						or
						{
							busyb from B to S;
							busytonea from S to A;
							continue Checking;
						}
					}
					or
					{
						noanswera from A to S;
						// ... B missing
						//continue Idle;
					}
				}
				or
				{
					busyb from B to S;
					// ... A missing
					continue Checking;
				}
			}
		}
		with
		{
			hangupa by A; // to S; stopringb to B;
		}

		onhook from A to S;
		//continue Idle;
	}
}
//*/


/*
global protocol Foo(role C, role S)
{
	rec XXX
	{
		choice at C
		{
			1() from C to S;
		}
		or
		{
			LIST() from C to S;
			choice at S
			{
				OK() from S to C;
				rec summary_choice_list
				{
					choice at S
					{
						DOT() from S to C;
					}
					or
					{
						SUM() from S to C;
						continue summary_choice_list;
					}
				}
			}
			or
			{
				ERR() from S to C;
			}
			continue XXX;
		}
	}
}
//*/


/*
// A = switching system agent, PA = calling part, PB = called party
global protocol AutomaticCallback(role PA, role A, role PB) {
	// idle state at PA
	ac() from PA to A; // waiting state at PA
	rec CHECKING
	{
		checkb() from A to PB;
		choice at PB
		{
			busyb() from PB to A;
			continue CHECKING;
		}
		or
		{
			available() from PB to A;
			ringa() from A to PA; //state?
			choice at PA
			{
				answera() from PA to A;
				// calling state at PA -- PA and PB are customers
				ringb() from A to PB;
				interruptible
				{
					choice at PB
					{
						answerb() from PB to A;
						connect() from A to PA;
					}
					or
					{
						busyb() from PB to A;
						busytonea() from A to PA;
						choice at PA
						{
							hangupa() from PA to A;
							stopringb() from A to PB;
							//end
						}
						or
						{
							continue CHECKING;
						}
					}
				}
				with
				{
					hangupa() by PA;
				}
			}
			or
			{
				noanswera() from PA to A; //idle state at PA
				//onhooka from PA to ??????
				//end
			}
		}
	}
}
//*/


/*global protocol AutomaticCallback(role PA, role A, role PB)
{
	ac() from PA to A;
	rec CHECKING
	{
		checkb() from A to PB;
		choice at PB
		{
			busyb() from PB to A;
			continue CHECKING;
		}
		or
		{
			available() from PB to A;
			ringa() from A to PA;
			choice at PA
			{
				answera() from PA to A;
				// calling state at PA -- PA and PB are customers
				ringb() from A to PB;
				choice at PB
				{
					answerb() from PB to A;
					connect() from A to PA;

					...hangupa() from PA to A;...

					stopringb() from A to PB;
					//end
				}
				or
				{
					busyb() from PB to A;
					busytonea() from A to PA;
					continue CHECKING;
				}
			}
			or
			{
				noanswera() from PA to A;
				//end
			}
		}
	}
}
//*/


/*
import Test2;

type <java> "java.lang.String" from "rt.jar" as String;
*/


/*
global protocol Foo(role A, role B)
{
	do Test2.Test2Proto(A, B);
	1() from A to B;
	choice at A
	{
		//1() from A to B;
		do Bar1(A, B);
		//1() from A to B;
		//do Foo(A, B);
	}
	or
	{
		//5() from A to B;
		do Bar2(A, B);
	}
	or
	{
		//2() from A to B;
		4() from A to B;
	}
}

global protocol Bar1(role C, role D)
{
	2() from C to D;
	3() from C to D;
	do Foo(C, D);
	//do Foo(D, C);
}

global protocol Bar2(role C, role D)
{
	5() from C to D;
	do Bar2(C, D);
}
//*/


/*
//import Test2 as Test;
//import Test2 as Test;
import Test2;
import test3.Test3 as Test4;  // <-
//import test3.Test3 as Test3;

global protocol Foo(role A, role B)
{
	1() from A to B;
	do Test2.Test2Proto1(A, B);
	do Test4.Test3Proto(A, B);
}
//*/


/*  // Simple name coincides with full name

module Test;

import Test;
//
 
 
module Test;

import Test as Test;
//


module Test;

import Test2 as Test;
*/


/*global protocol Foo(role A, role B, role C)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		2() from A to B;
	}
	or
	{
		2() from A to B;
	}
}*/

/*
import Test2 as Bar;

global protocol Foo(role A, role B)
{
	//do Test2.Test2Proto(A, B);
	do Bar.Test2Proto(A, B);
}
//*/

/*
global protocol Foo(role A, role B)
{
	1() from A to B;
	choice at A
	{
		2() from A to B;
	}
	or
	{
		do Bar(A, B);
	}
}

global protocol Bar(role A, role B)
{
	do Foo(A, B);
}
//*/


/*
// Test unused roledecl filtering in projections
global protocol Foo(role A, role B, role C)
{
	1() from A to B;
	do Bar(A, B, C);
}

global protocol Bar(role D, role E, role F)
{
	2() from D to F;
	do Foo(D, E, F);
}
//*/


/*
global protocol Foo(role A, role B)
{
	1() from A to B;
	do Bar(A, B);
	2() from A to B;
}

global protocol Bar(role A, role B)  // FIXME: bad unused role decls (wrt. subprotocol collected role occurrences)
{
	//3() from A to B;
}
//*/


/*
global protocol Foo(role A, role B)
{
	choice at A
	{
		1() from A to B;
		do Foo(A, B);
		//do Bar(A, B);
		//2() from A to B;
	}
	or
	{
		do Bar(A, B);
		//3() from A to B;
	}
	//4() from A to B;
}

global protocol Bar(role C, role D)
{
	5() from C to D;
	do Bar(C, D);
}
//*/


/*
global protocol Foo(role A, role B)
{
	choice at A
	{
		1() from A to B;
		do Foo(A, B);
		//3() from A to B;
	} or {
		2() from A to B;
		3() from A to B;
	}
	//3() from A to B;
}
//*/


/*
global protocol Foo(role A, role B)
{
	rec Z
	{
		choice at A
		{
			rec X
			{
				1() from A to B;
				continue X;
				//3() from A to B;
			}
			//3() from A to B;
		}
		or
		{
			rec Y
			{
				2() from A to B;
				//continue Y;
				//continue Z;
			}
		}
		//3() from A to B;
	}
	3() from A to B;
}
//*/


/*global protocol Foo(role A, role B)  // Project for A
{
	do Bar1<1(), 2()>(A, B);
	do Bar1<3(), 4()>(A, B);
}

global protocol Bar1<sig M1, sig M2>(role A, role B)
{
	do Bar2<M1, M2>(A, B, A);
}

global protocol Bar2<sig M1, sig M2>(role A, role B, role C)
{
	M1 from A to B;
	M2 from B to C;
}
//*/


/*global protocol Foo(role A, role B)
{
	do Bar(A, B);
}

global protocol Bar(role A, role B)
{
	choice at A
	{
		1() from A to B;
		do Bar(B, A);
	}
}
//*/


/*global protocol Foo(role A, role B)
{
	choice at A
	{
		1() from A to B;
	}
	
	rec X
	{
		choice at A
		{
			2() from A to B;
			continue X;
		}
		or
		{
			3() from A to B;
		}
	}
}
//*/


/*global protocol Foo(role A, role B)
{
	choice at A
	{
		rec X
		{
			//do Bar(A, B);
			1() from A to B;
			continue X;
		}
	}
	or
	{
		2() from A to B;
	}
}
//*/


/*global protocol Foo(role A, role B)
{
	rec X {
		1() from A to B;
		choice at A {
			//4() from A to B;
			rec Y {
				3() from A to B;
				continue X;
			}
		} or {
			2() from A to B;
		}
	}
}
//*/


/*global protocol Foo(role A, role B)
{
	1() from A to B;
	choice at A
	{
		do Bar(A, B);
	}
	or
	{
		//1() from A to B;
		2() from A to B;
	}
}

global protocol Bar(role A, role B)
{
	do Foo(A, B);
}
//*/


/*global protocol Foo(role A, role B)
{
	1() from A to B;
	choice at A
	{
		//2() from A to B;
		do Bar(A, B);
	}
	or
	{
		//1() from A to B;
		2() from A to B;
	}
}

global protocol Bar(role A, role B)
{
	//3() from A to B;
	do Foo(A, B);
}
//*/


/*global protocol Foo(role A, role B)
{
	//1() from A to B;
	choice at A
	{
		do Bar1(A, B);
	}
	or
	{
		do Bar2(A, B);
	}
	or
	{
		5() from A to B;
	}
}

global protocol Bar1(role A, role B)
{
	2() from A to B;
	3() from B to A;
	do Foo(A, B);
}

global protocol Bar2(role A, role B)
{
	4() from A to B;
	do Bar2(A, B);
}
//*/


/*global protocol Foo(role A, role B)
{
	//do Foo1<Test.String2>(A, B);
	do Foo1<String>(A, B);
	choice at A
	{
		1(String) from A to B;
		2() from A to B;
	}
	or
	{
		do Test2.Bar(A, B);
		//1() from A to B;
	}
}

global protocol Foo1<type T>(role A, role B)
{
	(T) from A to B;
}
//*/


/*
global protocol Foo(role A, role B)
{
	2() from A to B;
	choice at A
	{
		1() from A to B;
	}
	or
	{
		do Foo2(A, B);
	}
}

global protocol Foo2(role A, role B)
{
	do Foo3(A, B);
}

global protocol Foo3(role A, role B)
{
	do Foo(A, B);
}
//*/


/*
global protocol Foo(role A, role B)
{
	/*1() from A to B;
	2() from B to A;* /
	choice at B
	{
		1a() from B to A;
		//1b() from A to B;
	}
	or
	{
		2a() from B to A;
		//2b() from A to B;
	}
	/*rec X
	{
		choice at A
		{
			1() from A to B;
			2() from B to A;
			continue X;
		}
		or
			2() from A to B;
		}
	}* /
}
//*/


/*
global protocol Foo(role A, role B)
{
	1() from A to B;
	choice at A
	{
		2() from A to B;
		do Bar(A, B);
	}
	or
	{
		4() from A to B;
	}
}

global protocol Bar(role A, role B)
{
	3() from B to A;
	do Foo(B, A);
}
//*/

/*
global protocol Foo(role A, role B)
{
	0() from A to B;
	rec X
	{
		choice at A
		{
			1() from A to B;
			2() from B to A;
			continue X;
		}
		or
		{
			3() from A to B;
		}
	}
	4() from A to B;
}
//*/


/*
global protocol Foo(role A, role B)
{
	0() from A to B;
	choice at A
	{
		1a() from A to B;
	}
	or
	{
		2a() from A to B;
		2b() from B to A;
	}
	3() from B to A;
}
//*/

/*
global protocol Foo(role A, role B)
{
	rec X
	{
		continue X;
	}
}
//*/


/*
sig <java> "foo" from "bar" as M1;

global protocol Foo(role A, role B)
{
	choice at A
	{
		M1 from A to B;
	}
	or
	{
		//do Foo(A, B);  // Not guarded -- FSM translation would be weird
		//do Bar<M1>(A, B);
		do Bar<1()>(A, B);
	}
}

global protocol Bar<sig M>(role A, role B)
{
	M from A to B;
}
//*/


/*
sig <java> "foo" from "bar" as M1;

global protocol Foo<sig M>(role A, role B)
{
	() from A to B;
	M from A to B;
	M1 from A to B;
	//M2 from A to B;
}
//*/


/*
global protocol Foo<sig M2>(role A, role B)
{
	choice at A
	{
		//1() from A to B;
		//do Bar<1()>(A, B);
		//do Bar<2()>(A, B);
		M2 from A to B;
	}
	or
	{
		//M2 from A to B;
		//1() from A to B;
		//do Bar<M2>(A, B);
		do Bar<1()>(A, B);
	}
}

global protocol Bar<sig M3>(role C, role D)
{
	M3 from C to D;
}
//*/

/*
global protocol Foo(role A, role B)
{
	1() from A to B;
	do Test2.Bar(A, B);
	//3() from A to B;
}
//*/

/*
global protocol Foo(role A, role B)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		do Test2.Bar(A, B);
		//do Bar(A, B);
	}
}

global protocol Bar(role C, role D)
{
	//1() from C to D;
	2() from C to D;
}
//*/

/*
global protocol Foo(role A, role B)
{
	choice at A
	{
		1() from A to B;
	}
	or
	{
		//1() from A to B;
		2() from A to B;
	}
}
//*/

/*global protocol Foo(role A, role B)
{
	1() from A to B;
	do Foo(A, B);
	//3() from A to B;
}

global protocol Bar(role C, role D)
{
	2() from C to D;
	do Foo(C, D);
	//2() from C to D;
}*/

/*
global protocol MyProto(role A, role B, role C, role D)
{
	rec X {
		choice at A
		{
			1() from A to B;
			continue X;
			//1() from A to B;
		}
		or
		{
			//1() from A to B;
			2() from A to B;
			continue X;
		}
	}
	//3() from A to B;
	4() from C to D;
}
//*/
